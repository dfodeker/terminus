// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stores.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createStore = `-- name: CreateStore :one
INSERT INTO stores (id, gid, name, handle, address, status, default_currency, timezone, plan, tenant_id, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7, $8, $9, now(), now())
RETURNING id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid
`

type CreateStoreParams struct {
	Gid             sql.NullInt64
	Name            string
	Handle          string
	Address         string
	Status          string
	DefaultCurrency string
	Timezone        string
	Plan            string
	TenantID        uuid.NullUUID
}

func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, createStore,
		arg.Gid,
		arg.Name,
		arg.Handle,
		arg.Address,
		arg.Status,
		arg.DefaultCurrency,
		arg.Timezone,
		arg.Plan,
		arg.TenantID,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}

const createStoreForTenant = `-- name: CreateStoreForTenant :one

INSERT INTO stores (id, gid, name, handle, address, status, default_currency, timezone, plan, tenant_id, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, '', 'active', 'USD', 'UTC', $4, $5, now(), now())
RETURNING id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid
`

type CreateStoreForTenantParams struct {
	Gid      sql.NullInt64
	Name     string
	Handle   string
	Plan     string
	TenantID uuid.NullUUID
}

// Tenant-scoped store queries
func (q *Queries) CreateStoreForTenant(ctx context.Context, arg CreateStoreForTenantParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, createStoreForTenant,
		arg.Gid,
		arg.Name,
		arg.Handle,
		arg.Plan,
		arg.TenantID,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}

const deleteAllStores = `-- name: DeleteAllStores :exec
DELETE FROM stores
`

func (q *Queries) DeleteAllStores(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllStores)
	return err
}

const deleteStoreForTenant = `-- name: DeleteStoreForTenant :exec
DELETE FROM stores
WHERE id = $1 AND tenant_id = $2
`

type DeleteStoreForTenantParams struct {
	ID       uuid.UUID
	TenantID uuid.NullUUID
}

func (q *Queries) DeleteStoreForTenant(ctx context.Context, arg DeleteStoreForTenantParams) error {
	_, err := q.db.ExecContext(ctx, deleteStoreForTenant, arg.ID, arg.TenantID)
	return err
}

const getStoreByGID = `-- name: GetStoreByGID :one
SELECT id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid FROM stores
WHERE gid = $1
`

func (q *Queries) GetStoreByGID(ctx context.Context, gid sql.NullInt64) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByGID, gid)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}

const getStoreByHandle = `-- name: GetStoreByHandle :one
SELECT id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid FROM stores WHERE handle = $1
`

func (q *Queries) GetStoreByHandle(ctx context.Context, handle string) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByHandle, handle)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}

const getStoreByTenantAndHandle = `-- name: GetStoreByTenantAndHandle :one
SELECT id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid FROM stores
WHERE tenant_id = $1 AND handle = $2
`

type GetStoreByTenantAndHandleParams struct {
	TenantID uuid.NullUUID
	Handle   string
}

func (q *Queries) GetStoreByTenantAndHandle(ctx context.Context, arg GetStoreByTenantAndHandleParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByTenantAndHandle, arg.TenantID, arg.Handle)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}

const getStoreByTenantAndID = `-- name: GetStoreByTenantAndID :one
SELECT id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid FROM stores
WHERE tenant_id = $1 AND id = $2
`

type GetStoreByTenantAndIDParams struct {
	TenantID uuid.NullUUID
	ID       uuid.UUID
}

func (q *Queries) GetStoreByTenantAndID(ctx context.Context, arg GetStoreByTenantAndIDParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByTenantAndID, arg.TenantID, arg.ID)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}

const getStores = `-- name: GetStores :many
SELECT id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid FROM stores ORDER BY created_at ASC
`

func (q *Queries) GetStores(ctx context.Context) ([]Store, error) {
	rows, err := q.db.QueryContext(ctx, getStores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Handle,
			&i.Address,
			&i.Status,
			&i.DefaultCurrency,
			&i.Timezone,
			&i.Plan,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.Gid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoresByTenantID = `-- name: GetStoresByTenantID :many
SELECT id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid FROM stores
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetStoresByTenantID(ctx context.Context, tenantID uuid.NullUUID) ([]Store, error) {
	rows, err := q.db.QueryContext(ctx, getStoresByTenantID, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Handle,
			&i.Address,
			&i.Status,
			&i.DefaultCurrency,
			&i.Timezone,
			&i.Plan,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantID,
			&i.Gid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoresByTenantIDPaginated = `-- name: GetStoresByTenantIDPaginated :many
SELECT id, gid, name, handle, address, status, default_currency, timezone, plan, tenant_id, created_at, updated_at
FROM stores
WHERE tenant_id = $1
  AND (
    $2::boolean = false
    OR (created_at, id) < ($3::timestamptz, $4::uuid)
  )
ORDER BY created_at DESC, id DESC
LIMIT $5
`

type GetStoresByTenantIDPaginatedParams struct {
	TenantID uuid.NullUUID
	Column2  bool
	Column3  time.Time
	Column4  uuid.UUID
	Limit    int32
}

type GetStoresByTenantIDPaginatedRow struct {
	ID              uuid.UUID
	Gid             sql.NullInt64
	Name            string
	Handle          string
	Address         string
	Status          string
	DefaultCurrency string
	Timezone        string
	Plan            string
	TenantID        uuid.NullUUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) GetStoresByTenantIDPaginated(ctx context.Context, arg GetStoresByTenantIDPaginatedParams) ([]GetStoresByTenantIDPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getStoresByTenantIDPaginated,
		arg.TenantID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoresByTenantIDPaginatedRow
	for rows.Next() {
		var i GetStoresByTenantIDPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Gid,
			&i.Name,
			&i.Handle,
			&i.Address,
			&i.Status,
			&i.DefaultCurrency,
			&i.Timezone,
			&i.Plan,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStore = `-- name: UpdateStore :one
UPDATE stores
SET
    name = $2,
    handle = $3,
    updated_at = now()
WHERE id = $1
RETURNING id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid
`

type UpdateStoreParams struct {
	ID     uuid.UUID
	Name   string
	Handle string
}

func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, updateStore, arg.ID, arg.Name, arg.Handle)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}

const updateStoreForTenant = `-- name: UpdateStoreForTenant :one
UPDATE stores
SET
    name = $3,
    handle = $4,
    address = $5,
    status = $6,
    default_currency = $7,
    timezone = $8,
    plan = $9,
    updated_at = now()
WHERE id = $1 AND tenant_id = $2
RETURNING id, name, handle, address, status, default_currency, timezone, plan, created_at, updated_at, tenant_id, gid
`

type UpdateStoreForTenantParams struct {
	ID              uuid.UUID
	TenantID        uuid.NullUUID
	Name            string
	Handle          string
	Address         string
	Status          string
	DefaultCurrency string
	Timezone        string
	Plan            string
}

func (q *Queries) UpdateStoreForTenant(ctx context.Context, arg UpdateStoreForTenantParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, updateStoreForTenant,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.Handle,
		arg.Address,
		arg.Status,
		arg.DefaultCurrency,
		arg.Timezone,
		arg.Plan,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Handle,
		&i.Address,
		&i.Status,
		&i.DefaultCurrency,
		&i.Timezone,
		&i.Plan,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantID,
		&i.Gid,
	)
	return i, err
}
