// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (id, gid, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at)
VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
RETURNING id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid
`

type CreateProductParams struct {
	Gid              sql.NullInt64
	StoreID          uuid.UUID
	Handle           string
	Name             string
	Description      sql.NullString
	InventoryTracked bool
	Sku              sql.NullString
	Tags             sql.NullString
	Status           string
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Gid,
		arg.StoreID,
		arg.Handle,
		arg.Name,
		arg.Description,
		arg.InventoryTracked,
		arg.Sku,
		arg.Tags,
		arg.Status,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Handle,
		&i.Name,
		&i.Description,
		&i.InventoryTracked,
		&i.Sku,
		&i.Tags,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Gid,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :one
DELETE FROM products
WHERE id = $1 AND store_id = $2
RETURNING id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid
`

type DeleteProductParams struct {
	ID      uuid.UUID
	StoreID uuid.UUID
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, deleteProduct, arg.ID, arg.StoreID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Handle,
		&i.Name,
		&i.Description,
		&i.InventoryTracked,
		&i.Sku,
		&i.Tags,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Gid,
	)
	return i, err
}

const getProductByGID = `-- name: GetProductByGID :one
SELECT id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid FROM products
WHERE gid = $1
`

func (q *Queries) GetProductByGID(ctx context.Context, gid sql.NullInt64) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByGID, gid)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Handle,
		&i.Name,
		&i.Description,
		&i.InventoryTracked,
		&i.Sku,
		&i.Tags,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Gid,
	)
	return i, err
}

const getProductByHandle = `-- name: GetProductByHandle :one
SELECT id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid FROM products
WHERE store_id = $1 AND handle = $2
`

type GetProductByHandleParams struct {
	StoreID uuid.UUID
	Handle  string
}

func (q *Queries) GetProductByHandle(ctx context.Context, arg GetProductByHandleParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByHandle, arg.StoreID, arg.Handle)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Handle,
		&i.Name,
		&i.Description,
		&i.InventoryTracked,
		&i.Sku,
		&i.Tags,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Gid,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid FROM products
WHERE id = $1 AND store_id = $2
`

type GetProductByIDParams struct {
	ID      uuid.UUID
	StoreID uuid.UUID
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, arg.ID, arg.StoreID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Handle,
		&i.Name,
		&i.Description,
		&i.InventoryTracked,
		&i.Sku,
		&i.Tags,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Gid,
	)
	return i, err
}

const getProductByIDOnly = `-- name: GetProductByIDOnly :one
SELECT id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid FROM products
WHERE id = $1
`

func (q *Queries) GetProductByIDOnly(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByIDOnly, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Handle,
		&i.Name,
		&i.Description,
		&i.InventoryTracked,
		&i.Sku,
		&i.Tags,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Gid,
	)
	return i, err
}

const getProductsByStore = `-- name: GetProductsByStore :many
SELECT id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid FROM products
WHERE store_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetProductsByStore(ctx context.Context, storeID uuid.UUID) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Handle,
			&i.Name,
			&i.Description,
			&i.InventoryTracked,
			&i.Sku,
			&i.Tags,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Gid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByStorePaginated = `-- name: GetProductsByStorePaginated :many
SELECT id, gid, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at
FROM products
WHERE store_id = $1
  AND (
    $2::boolean = false
    OR (created_at, id) < ($3::timestamptz, $4::uuid)
  )
ORDER BY created_at DESC, id DESC
LIMIT $5
`

type GetProductsByStorePaginatedParams struct {
	StoreID uuid.UUID
	Column2 bool
	Column3 time.Time
	Column4 uuid.UUID
	Limit   int32
}

type GetProductsByStorePaginatedRow struct {
	ID               uuid.UUID
	Gid              sql.NullInt64
	StoreID          uuid.UUID
	Handle           string
	Name             string
	Description      sql.NullString
	InventoryTracked bool
	Sku              sql.NullString
	Tags             sql.NullString
	Status           string
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) GetProductsByStorePaginated(ctx context.Context, arg GetProductsByStorePaginatedParams) ([]GetProductsByStorePaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByStorePaginated,
		arg.StoreID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByStorePaginatedRow
	for rows.Next() {
		var i GetProductsByStorePaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Gid,
			&i.StoreID,
			&i.Handle,
			&i.Name,
			&i.Description,
			&i.InventoryTracked,
			&i.Sku,
			&i.Tags,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET 
    handle = $3,
    name = $4,
    description = $5,
    inventory_tracked = $6,
    sku = $7,
    tags = $8,
    status = $9,
    updated_at = NOW()
WHERE id = $1 AND store_id = $2
RETURNING id, store_id, handle, name, description, inventory_tracked, sku, tags, status, created_at, updated_at, gid
`

type UpdateProductParams struct {
	ID               uuid.UUID
	StoreID          uuid.UUID
	Handle           string
	Name             string
	Description      sql.NullString
	InventoryTracked bool
	Sku              sql.NullString
	Tags             sql.NullString
	Status           string
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.StoreID,
		arg.Handle,
		arg.Name,
		arg.Description,
		arg.InventoryTracked,
		arg.Sku,
		arg.Tags,
		arg.Status,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Handle,
		&i.Name,
		&i.Description,
		&i.InventoryTracked,
		&i.Sku,
		&i.Tags,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Gid,
	)
	return i, err
}
